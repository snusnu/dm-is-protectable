h2. dm-is-protectable

A DataMapper plugin that allows to protect property assignment.
This makes it very easy to implement permission checking in the model
(just like any other _business rule_).

h3. Shoutouts

Big Thx to <a href="http://perens.com/">Bruce Perens</a>
for inspiring this with his ModelSecurity plugin for rails!

h3. Overview

@dm-is-protectable@ allows you to specify security permissions 
on any or all of the properties of any @DataMapper::Resource@.

Security permissions are specified in the declaration of the resource's class, 
The specification includes the names of the properties to which permissions apply, 
and an optional permission test that should return true or false 
depending on whether the access should be allowed or denied. The permission test
can be specified as either a @Symbol@ referencing an instance method on the resource,
or as a @lambda@ or @Proc@ to which the current resource instance is @yielded@.
Either way, @:if@ and @:unless@ can be used to clearly express the intent of the test.

_No permission_ test is the same as specifying a test that _always returns true_.

<pre>
<code>
let :read    specifies when the attribute can be read, 
let :write   specifies when it can be written
let :access  does both.
</code>
</pre>

h3. Examples (taken from specs)

<pre>
<code>
class Person

  include DataMapper::Resource

  property :id,         Serial

  property :nick,       String
  property :firstname,  String
  property :lastname,   String
  property :email,      String    
  property :phone,      String      

  property :mood,       String
  property :shoutbox,   String
  property :pm,         String

  property :birthday,   String
  property :hobbies,    String
  property :status,     String

  property :created_at, DateTime
  property :updated_at, DateTime


  is :protectable

  let :read, :nick                      # would normally be merged into one
  let :read, [ :firstname, :lastname ]  # splitted here only for demonstration
  let :read, :pm,                       :if     => :funny?
  let :read, [ :phone, :email ],        :unless => :paranoid?

  let :write, :pm
  let :write, :nick,                    :if     => :funny?
  let :write, [ :phone, :email ],       :unless => :serious?

  let :access, :mood
  let :access, :status,                 :if     => :funny?
  let :access, [ :birthday, :hobbies ], :unless => :serious?


  # permission checking helpers
  [ :paranoid, :funny, :serious ].each do |mood|
    define_method "#{mood}!" do
      self.mood = "'#{mood}'"
    end
    define_method "#{mood}?" do
      self.mood == "'#{mood}'"
    end
  end

end
</code>
</pre>

h3. Wildcard guards

If no properties are specified for @let@, that means that the _guard_ 
will be hooked before all properties of the resource. 
These _guards_ are run first, then any _guards_ for the specific property. 
Any _guard_ that returns @false@ ends the run, further tests will not be evaluated.

<pre>
<code>
let :read                  # everything is readable
let :write, :if => admin?  # admins can write everything
let :access                # everything is readable and writable
</code>
</pre>

If *no* security permissions are declared for a property, that property
may always be accessed.

The security tests themselves may access any data with impunity. 
A thread local variable is used to disable further security testing 
while a security test is in progress.


h3. lambdas or Procs as guards

If the _guard_ is specified as a @lambda@ or @Proc@, the current 
@DataMapper::Resource@ gets @yielded@ to the block.

<pre>
<code>
let :read, :phone_number :if => lambda do |r|
  return r.current_user.has_role?(:admin)
end
</code>
</pre>

h3. Accessing Security Test Results

The two instance methods, @readable?@ and @writable?@ are provided
to inform the program if a particular property can be accessed.

h3. Exceptions

DataMapper provides two internal methods to access properties: 
DataMapper::Property#get and DataMapper::Property#set. 
'before hooks' are registered on these methods that will raise 
various subclasses of *SecurityError* when an unpermitted access is attempted.
The following exceptions may occur when using @dm-is-protectable@

<pre>
<code>
class DmIsProtectableException < SecurityError; end
class InvalidPermission < DmIsProtectableException; end
class IllegalPropertyAccess < DmIsProtectableException; end
class IllegalReadAccess < IllegalPropertyAccess; end
class IllegalWriteAccess < IllegalPropertyAccess; end
class IllegalDisplayAccess < IllegalPropertyAccess; end
</code>
</pre>


h3. Support for let :display

*TODO: think about supporting this here (plus in a separate gem)*

A companion mechanism could be used to control views.

 let :display :phone_nr, :if => admin?

let :display could be useful for specifying if a table view should have a
column for a particular property. Its tests would have be declared as class
methods of the resource, while the tests of let :read, let :write, and
let :access are instance methods. This is because the information declared
by let :display is accessed before iteration over active records begins.

The class method @displayable?@ will return @true@ or @false@ 
depending upon whether a particular property should should be displayed or not. 
These can be used to modify a view so that any non-writable data 
will not be presented in an editable field.

A DisplayHelper module could overload the methods that are usually used 
to edit models so that they will not attempt to read or write what they 
aren't permitted, and will render appropriately for the permissions 
on any resource property.

Those methods (in rails) are:
* check_box 
* file_field
* hidden_field
* password_field 
* radio_button
* text_area
* text_field